# Copyright (c) 2014 Stefan.Eilemann@epfl.ch

# Configures the build for a simple library:
#   common_library(<Name>)
#
# Uses:
# * NAME_SOURCES for all compilation units
# * NAME_HEADERS for all internal header files
# * NAME_PUBLIC_HEADERS for public, installed header files
# * NAME_LINK_LIBRARIES for dependencies of name
# * NAME_LIBRARY_TYPE or COMMON_LIBRARY_TYPE for SHARED or STATIC library, with
#   COMMON_LIBRARY_TYPE being an option stored in the CMakeCache.
# * NAME_OMIT_PROJECT_HEADER when set, no project header (name.h) is generated.
# * NAME_INCLUDE_NAME for the include directory and project include header
# * NAME_NAMESPACE for api.h and version.h
# * VERSION for the API version
# * VERSION_ABI for the ABI version
# * Optional Qt support:
# ** NAME_MOC_HEADERS list of internal moc input headers
# ** NAME_MOC_PUBLIC_HEADERS list of public moc input headers, to be installed
# ** NAME_UI_FORMS list of all .ui input files
# ** NAME_RESOURCES list of all .qrc resource files
#
# If NAME_LIBRARY_TYPE is a list, libraries are built of each specified
# (i.e. shared and static) type. Whichever is first becomes the library
# target associated with <Name>.
#
# Builds libName and installs it. Installs the public headers to include/name.
# Generates a NAME_INCLUDE_NAME/{BASE_NAME of NAME_INCLUDE_NAME}.h
# including all public headers.

include(InstallFiles)
include(CommonQtSupport)

set(COMMON_LIBRARY_TYPE SHARED CACHE STRING
  "Library type {any combination of SHARED, STATIC}")
set_property(CACHE COMMON_LIBRARY_TYPE PROPERTY STRINGS SHARED STATIC)

macro(GENERATE_PROJECT_HEADER NAME)
  get_filename_component(BASE_NAME ${INCLUDE_NAME} NAME)

  set(PROJECT_GENERATED_HEADER
    ${OUTPUT_INCLUDE_DIR}/${INCLUDE_NAME}/${BASE_NAME}.in.h)

  file(WRITE ${PROJECT_GENERATED_HEADER}
    "// generated by CommonLibrary.cmake, do not edit\n"
    "#ifndef ${NAME}_H\n"
    "#define ${NAME}_H\n")
  foreach(PUBLIC_HEADER ${PUBLIC_HEADERS})
    if(IS_ABSOLUTE ${PUBLIC_HEADER})
      get_filename_component(PUBLIC_HEADER ${PUBLIC_HEADER} NAME)
    endif()
    if(NOT PUBLIC_HEADER MATCHES "defines.+\\.h" AND
        (PUBLIC_HEADER MATCHES ".*\\.h$" OR
        PUBLIC_HEADER MATCHES ".*\\.hpp$"))

      file(APPEND ${PROJECT_GENERATED_HEADER}
        "#include <${INCLUDE_NAME}/${PUBLIC_HEADER}>\n")
    endif()
  endforeach()
  file(APPEND ${PROJECT_GENERATED_HEADER} "#endif\n")
  set(PROJECT_INCLUDE_HEADER
    ${OUTPUT_INCLUDE_DIR}/${INCLUDE_NAME}/${BASE_NAME}.h)

  configure_file(
    ${PROJECT_GENERATED_HEADER}
    ${PROJECT_INCLUDE_HEADER} COPYONLY)
  list(APPEND PUBLIC_HEADERS ${PROJECT_INCLUDE_HEADER})
endmacro()

# applying CMAKE_C(XX)_FLAGS to add_library only works from parent scope, hence
# the macro calling the function _common_library
macro(COMMON_LIBRARY Name)
  common_compiler_flags()
  _common_library(${Name} ${ARGN})
endmacro()

function(_common_library Name)
  string(TOUPPER ${Name} NAME)

  set(INCLUDE_NAME ${${NAME}_INCLUDE_NAME})
  if(NOT INCLUDE_NAME)
    set(INCLUDE_NAME ${PROJECT_INCLUDE_NAME})
  endif()

  set(namespace ${${NAME}_NAMESPACE})
  if(NOT namespace)
    set(namespace ${PROJECT_namespace})
  endif()
  string(TOUPPER ${namespace} NAMESPACE)

  set(SOURCES ${${NAME}_SOURCES})
  set(HEADERS ${${NAME}_HEADERS} ${${NAME}_MOC_HEADERS})
  set(PUBLIC_HEADERS ${${NAME}_PUBLIC_HEADERS} ${${NAME}_MOC_PUBLIC_HEADERS})
  set(LINK_LIBRARIES ${${NAME}_LINK_LIBRARIES})

  configure_file(${CMAKE_SOURCE_DIR}/CMake/common/cpp/api.h
    ${OUTPUT_INCLUDE_DIR}/${INCLUDE_NAME}/api.h @ONLY)
  configure_file(${CMAKE_SOURCE_DIR}/CMake/common/cpp/version.h
    ${OUTPUT_INCLUDE_DIR}/${INCLUDE_NAME}/version.h @ONLY)
  configure_file(${CMAKE_SOURCE_DIR}/CMake/common/cpp/version.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/version.cpp @ONLY)

  # ${NAMESPACE}_API= -> Fix cppcheck error about not including version.h
  list(APPEND CPPCHECK_EXTRA_ARGS
    -D${NAME}_STATIC= -D${NAMESPACE}_API=)

  list(APPEND PUBLIC_HEADERS
    ${OUTPUT_INCLUDE_DIR}/${INCLUDE_NAME}/api.h
    ${OUTPUT_INCLUDE_DIR}/${INCLUDE_NAME}/version.h)
  list(APPEND SOURCES ${CMAKE_CURRENT_BINARY_DIR}/version.cpp)

  if(NOT ${NAME}_OMIT_PROJECT_HEADER)
    generate_project_header(${NAME})
  endif()

  common_qt_support(${NAME})
  list(APPEND SOURCES ${COMMON_QT_SUPPORT_SOURCES})

  if(SOURCES)
    list(SORT SOURCES)
  endif()
  if(HEADERS)
    list(SORT HEADERS)
  endif()
  if(PUBLIC_HEADERS)
    list(SORT PUBLIC_HEADERS)
  endif()

  source_group(
    ${INCLUDE_NAME} FILES ${SOURCES} ${HEADERS} ${PUBLIC_HEADERS})
  if(NOT ${NAME}_LIBRARY_TYPE)
    set(${NAME}_LIBRARY_TYPE ${COMMON_LIBRARY_TYPE})
    if(NOT ${NAME}_LIBRARY_TYPE)
      set(${NAME}_LIBRARY_TYPE SHARED)
    endif()
  endif()
  foreach(LIBRARY_TYPE ${${NAME}_LIBRARY_TYPE})
    set(LIBNAME ${Name})
    if(TARGET ${Name})
      set(LIBNAME "${Name}_${LIBRARY_TYPE}")
    endif()
    add_library(${LIBNAME} ${LIBRARY_TYPE} ${SOURCES} ${HEADERS} ${PUBLIC_HEADERS})
    set_target_properties(${LIBNAME}
      PROPERTIES VERSION ${VERSION} SOVERSION ${VERSION_ABI} OUTPUT_NAME ${Name})
    target_link_libraries(${LIBNAME} ${LINK_LIBRARIES})
    install(TARGETS ${LIBNAME}
      ARCHIVE DESTINATION ${LIBRARY_DIR} COMPONENT dev
      RUNTIME DESTINATION bin COMPONENT lib
      LIBRARY DESTINATION ${LIBRARY_DIR} COMPONENT lib)
  endforeach()

  if(MSVC AND "${${NAME}_LIBRARY_TYPE}" MATCHES "SHARED")
    install(FILES ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/Debug/${Name}.pdb
      DESTINATION bin COMPONENT lib CONFIGURATIONS Debug)
    install(FILES ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/RelWithDebInfo/${Name}.pdb
      DESTINATION bin COMPONENT lib CONFIGURATIONS RelWithDebInfo)
  endif()

  # install(TARGETS ... PUBLIC_HEADER ...) flattens directories
  install_files(include/${INCLUDE_NAME}
    FILES ${PUBLIC_HEADERS} COMPONENT dev)
endfunction()
